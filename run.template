#include "%TaskFile%"
#include <chrono>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

namespace JHelper
{
	struct Test
	{
		std::string m_input, m_output;
		bool m_active, m_hasOutput;

		static std::string trim(std::string data)
		{
		    for(std::size_t index = 1; index < data.size(); ++index)
		    {
		        if(data.at(index) == '\n')
		        {
                    while(index && std::isblank(data.at(index - 1)))
                    {
                        data.erase(data.begin() + index - 1);
                        --index;
                    }
		        }
		    }
		    while(!data.empty() && std::isspace(data.back()))
		    {
		        data.pop_back();
		    }
			return data;
		}

		void set_output(const std::string& output)
		{
			m_output = Test::trim(output);
		}

		Test(const std::string& input, const std::string& output, const bool& active, const bool& hasOutput) : m_input{input}, m_output{output}, m_active{active}, m_hasOutput{hasOutput}
		{
            m_input = Test::trim(m_input);
			m_output = Test::trim(m_output);
		}

		bool check(const std::string& output) const
		{
			return Test::trim(output) == m_output;
		}
	};
}

std::string red{"\x1B[31m"}, green{"\x1B[32m"}, yellow{"x1B[33m"}, blue{"\x1B[34m"}, original{"\033[0m"};

std::uint32_t testID{};
long double testTime{};
bool testOK{};
std::string testOutput{};

void run_test(JHelper::Test& test, const std::int32_t& stressTestIteration = 0, const bool& showTestingOutput = false)
{
	if(!stressTestIteration)
	{
		std::cerr << blue << "Test #" << ++testID << original << std::endl;
		std::cerr << blue << "Input:" << std::endl << original << test.m_input << std::endl;
		std::cerr << blue << "Expected output:" << std::endl << original;
		if(test.m_hasOutput)
		{
			std::cerr << test.m_output;
		}
		else
		{
			std::cerr << yellow << "N/A" << original;
		}
		std::cerr << std::endl;
	}
	if(test.m_active)
	{
		std::istringstream in(test.m_input);
		std::ostringstream out;
		std::chrono::time_point<std::chrono::high_resolution_clock> start{std::chrono::high_resolution_clock::now()};
		%ClassName% solver;
		solver.setup();
		%SolverCall% testTime = std::chrono::duration_cast<std::chrono::duration<long double, std::ratio<1> >>(std::chrono::high_resolution_clock::now() - start).count();
		string output{test.trim(out.str())};
		if(!stressTestIteration)
		{
			std::cerr << blue << "Actual output:" << std::endl << original << output << std::endl;
		}
		if(test.m_hasOutput)
		{
			testOK = test.check(output);
			if(!stressTestIteration)
			{
				std::cerr << blue << "Result: " << original;
				if(testOK)
				{
					std::cerr << green << "Right answer";
				}
				else
				{
					std::cerr << red << "Wrong answer";
				}
				std::cerr << original << std::endl;
			}
		}
		testOutput = output;
		if(!stressTestIteration)
		{
			std::cerr << blue << "Time: " << testTime << "s." << original << std::endl;
		}
		if(test.m_hasOutput && !testOK && stressTestIteration)
		{
		    std::cerr << red << "Stress Test #" << stressTestIteration << original << std::endl;
            if(%ClassName%::showFalseTestOutput)
            {
                std::cerr << blue << "Input:" << std::endl << original << test.m_input << std::endl;
                std::cerr << blue << "Expected output:" << std::endl << original;
                if(test.m_hasOutput)
                {
                    std::cerr << test.m_output;
                }
                else
                {
                    std::cerr << yellow << "N/A" << original;
                }
                std::cerr << std::endl;
                std::cerr << blue << "Actual output:" << std::endl << original << output << std::endl;
		    }
		}
	}
	else
	{
		std::cerr << yellow << "SKIPPED" << original << std::endl;
	}
	if(!stressTestIteration)
	{
		std::cerr << std::endl;
	}
	if(testOK && showTestingOutput)
	{
		std::cerr << green << "Stress Test #" << stressTestIteration << original << std::endl;
	}
}

int main(int argc, char *argv[])
{
    static_assert((%ClassName%::stressTestIterations ? true : false) ^ %ClassName%::bruteForceAllIterations);
	unused(argc, argv);
	std::vector<JHelper::Test> tests{%Tests%};
	std::cerr << std::fixed;
	long double solveMaximalTime{}, solveAverageTime{}, bruteForceMaximalTime{}, bruteForceAverageTime{};
	bool allOK = true;
	for(JHelper::Test& test : tests)
	{
		run_test(test);
		solveMaximalTime = std::max(solveMaximalTime, testTime);
		solveAverageTime += testTime;
		allOK &= (!test.m_hasOutput || testOK);
	}
	for(std::uint32_t stressTestIteration = 1; stressTestIteration <= %ClassName%::stressTestIterations && allOK; ++stressTestIteration)
	{
		std::ostringstream generatedTestInput;
		%ClassName%::generate_test(generatedTestInput, stressTestIteration);
		JHelper::Test generatedTest{generatedTestInput.str(),
		                            "",
		                            true,
		                            false};
		%ClassName%::bruteForceSolveIteration = true;
		run_test(generatedTest, -1, false);
		bruteForceMaximalTime = std::max(bruteForceMaximalTime, testTime);
		bruteForceAverageTime += testTime;
		%ClassName%::bruteForceSolveIteration = false;
		if(!testOutput.empty())
		{
			generatedTest.set_output(testOutput);
			generatedTest.m_hasOutput = true;
		}
		run_test(generatedTest, stressTestIteration, %ClassName%::showTestingOutput);
		solveMaximalTime = std::max(solveMaximalTime, testTime);
		solveAverageTime += testTime;
		allOK &= testOK;
	}
	solveAverageTime /= (tests.size() + %ClassName%::stressTestIterations);
	if(%ClassName%::stressTestIterations && (%ClassName%::showTestingOutput || %ClassName%::showFalseTestOutput))
	{
		std::cerr << std::endl;
	}
	if(allOK)
	{
		std::cerr << green << "All Right";
	}
	else
	{
		std::cerr << red << "Some Wrong";
	}
	std::cerr << original << std::endl;
	std::cerr << "Maximal solve() time: " << solveMaximalTime << "s." << original << std::endl;
	std::cerr << "Average solve() time: " << solveAverageTime << "s." << original << std::endl;
	if(%ClassName%::stressTestIterations)
	{
	    bruteForceAverageTime /= %ClassName%::stressTestIterations;
		std::cerr << "Maximal brute_force() time: " << bruteForceMaximalTime << "s." << original << std::endl;
		std::cerr << "Average brute_force() time: " << bruteForceAverageTime << "s." << original << std::endl;
	}
}